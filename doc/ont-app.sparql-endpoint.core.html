<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.sparql-endpoint.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Sparql-endpoint</span> <span class="project-version">0.1.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to sparql-endpoint</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="ont-app.sparql-endpoint.core.html"><div class="inner"><span>ont-app.sparql-endpoint.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-angle-bracket-uri"><div class="inner"><span>angle-bracket-uri</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-default-translators"><div class="inner"><span>default-translators</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-iri-for"><div class="inner"><span>iri-for</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-parse-prologue"><div class="inner"><span>parse-prologue</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-parse-xsd-value"><div class="inner"><span>parse-xsd-value</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-simplifier-for-prologue"><div class="inner"><span>simplifier-for-prologue</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-simplify"><div class="inner"><span>simplify</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-ask"><div class="inner"><span>sparql-ask</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-construct"><div class="inner"><span>sparql-construct</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-query"><div class="inner"><span>sparql-query</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-select"><div class="inner"><span>sparql-select</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-update"><div class="inner"><span>sparql-update</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-the-iri-factory"><div class="inner"><span>the-iri-factory</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-type-mapper"><div class="inner"><span>type-mapper</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.sparql-endpoint.core</h1><div class="doc"><pre class="plaintext">Functions to support interacting with a SPARQL endpoint.
See also `<a href="https://www.w3.org/TR/sparql11-query">https://www.w3.org/TR/sparql11-query</a>`.
</pre></div><div class="public anchor" id="var-angle-bracket-uri"><h3>angle-bracket-uri</h3><div class="usage"><code>(angle-bracket-uri s)</code></div><div class="doc"><pre class="plaintext">returns &lt;`s`&gt; if it matches the scheme for a URI, else returns `s`.
</pre></div></div><div class="public anchor" id="var-default-translators"><h3>default-translators</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A map with keys :uri :lang :datatype, each mapping to &lt;translator&gt;
Where
&lt;translator&gt; := (fn[var-value]) -&gt; &lt;translated value&gt;
&lt;var-value&gt; :={'value' &lt;value&gt;
               'type' 'uri' | 'literal'
               ...maybe...
               'xml:lang' &lt;lang&gt; (if literal)
               'datatype' &lt;datatype&gt; (if literal)
              }
</pre></div></div><div class="public anchor" id="var-iri-for"><h3>iri-for</h3><div class="usage"><code>(iri-for uri)</code></div><div class="doc"><pre class="plaintext">Returns an instance of `org.apache.jena.iri.impl.IRIImpl` for `uri`
Where
&lt;uri&gt; a string, typically the 'value' value of a SELECT binding whose 'type' 
  value is 'uri'
NOTE: this does not seem to be a very mature class in Jena, and you may need 
  to poke around a bit to find methods that don't trigger NYI errors</pre></div></div><div class="public anchor" id="var-parse-prologue"><h3>parse-prologue</h3><div class="usage"><code>(parse-prologue query)</code></div><div class="doc"><pre class="plaintext">Returns [&lt;base&gt;, &lt;uri-to-qname&gt;, &lt;qname-to-uri&gt;] parsed from the 
  &lt;prologue&gt; to `query`
Where
&lt;base&gt; is a URI string for the base of &lt;query&gt;
&lt;uri-to-qname&gt; := fn[&lt;uri&gt;] -&gt; &lt;quickname&gt;, or &lt;uri&gt; if there was no matching
  prefix in &lt;prolog&gt;
&lt;qname-to-uri&gt; := fn[&lt;qname&gt;] -&gt; &lt;uri&gt;   or &lt;qname&gt; if there
  was no matching prefix in &lt;prologue&gt;
&lt;uri&gt; is typically a URI with a prefix defined in the &lt;prologue&gt;, but
  may be any string
&lt;qname&gt; is typically a qname with a prefix defined in &lt;prologue&gt;,
  but may be any string
&lt;prologue&gt; is the prologue parsed from &lt;query&gt;, for which see
  spex at `<a href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a>`.
</pre></div></div><div class="public anchor" id="var-parse-xsd-value"><h3>parse-xsd-value</h3><div class="usage"><code>(parse-xsd-value literal)</code></div><div class="doc"><pre class="plaintext">
Returns &lt;translated-value&gt; for `literal`
Where
&lt;literal&gt; is a sparql binding value-map s.t.
  {type literal, datatype &lt;datatype&gt;, value &lt;value&gt; ...}
&lt;translated-value&gt; is an instance of the xsd datatype associated with
  &lt;datatype&gt; specified for &lt;value&gt;, or &lt;value&gt; if no translation can be
  found.
&lt;datatype&gt; is a string indicating the datatype associated with &lt;value&gt;,
  which may be an xsd datatype
</pre></div></div><div class="public anchor" id="var-simplifier-for-prologue"><h3>simplifier-for-prologue</h3><div class="usage"><code>(simplifier-for-prologue query)</code><code>(simplifier-for-prologue query translators)</code></div><div class="doc"><pre class="plaintext">Returns a function (fn[&lt;var-map&gt;] -&gt; {&lt;var-keyword&gt; &lt;translated-value&gt;, ...}
for each &lt;var&gt; in `var-map`, transating URIs into qnames derived from the
prologue to `query`, and otherwise using `translators` (default
`default-translators`)</pre></div></div><div class="public anchor" id="var-simplify"><h3>simplify</h3><div class="usage"><code>(simplify var-map)</code><code>(simplify var-map translators)</code></div><div class="doc"><pre class="plaintext">Returns {&lt;var-keyword&gt; &lt;translated-value&gt;, ...} for each &lt;var&gt; in `var-map`,
  translated according to `translators` (default `default-translators`)
Where
&lt;var-map&gt; := {&lt;var&gt; &lt;var-value&gt;...}
&lt;var&gt; is a string typically corresponding to a variable in a SELECT query
&lt;var-value&gt; is a map with keys in the set #{type value xml:lang datatype},
  per the SPARQL 1.1 specification for SELECT queries.
&lt;var-keyword&gt; is keyword corresponding to &lt;var&gt;
&lt;translated-value&gt; is &lt;value&gt; from &lt;var-value&gt;, translated using &lt;translators&gt;
&lt;translators&gt; is a map with keys in #{:uri :lang :datatype}, each of which
  maps to a (fn[var-value])-&gt; &lt;translated-value&gt;, depending on whether
  &lt;var-value&gt; represents a URI, a literal with a language tag, or a literal
  with a specified datatype. Default is simply to render the 'value' field.
Note: see also `<a href="https://www.w3.org/TR/sparql11-results-json/">https://www.w3.org/TR/sparql11-results-json/</a>`
</pre></div></div><div class="public anchor" id="var-sparql-ask"><h3>sparql-ask</h3><div class="usage"><code>(sparql-ask endpoint query)</code><code>(sparql-ask endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns boolean value per `query` posed to `endpoint`, through an
HTTP call possibly informed by `http-req`.
Where
&lt;query&gt; is a SPARQL ASK query
&lt;endpoint&gt; is a SPARQL endpoint
&lt;http-req&gt; := {&lt;param&gt; &lt;spec&gt;, ...}
&lt;param&gt; is anything described in `<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`
Though :form-params will be overridden.

</pre></div></div><div class="public anchor" id="var-sparql-construct"><h3>sparql-construct</h3><div class="usage"><code>(sparql-construct endpoint query)</code><code>(sparql-construct endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns &lt;expression&gt; for `query` posed to `endpoint`, possibly informed
  by `http-req`
Where
&lt;query&gt; := a SPARQL CONSTRUCT query
&lt;endpoint&gt; the URL string of a SPARQL endpoint
&lt;http-req&gt; := {?param...}
&lt;param&gt; is anything described in `<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`
  Though :form-params will be overridden.
  The default :accept parameter is text/turtle.
</pre></div></div><div class="public anchor" id="var-sparql-query"><h3>sparql-query</h3><div class="usage"><code>(sparql-query endpoint query)</code><code>(sparql-query endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns output of &lt;response-body&gt; for SPARQL `query`
  posed to `endpoint`, possibly informed by `http-req`
Where
&lt;response-body&gt; is the body of the response to &lt;query&gt;, posed to &lt;endpoint&gt;
  via an HTTP GET call which may be informed by &lt;param&gt;s in &lt;http-req&gt;
&lt;http-req&gt; := {&lt;param&gt; &lt;spec&gt;,...}, default is {}
&lt;param&gt; is anything described in &lt;`<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`&gt;
  typically :debug or authentication parameters
  :query-params will be overridden.
  {:cookie-policy :standard} will be asserted by default
</pre></div></div><div class="public anchor" id="var-sparql-select"><h3>sparql-select</h3><div class="usage"><code>(sparql-select endpoint query)</code><code>(sparql-select endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns &lt;bindings&gt; for `query` posed to `endpoint`, using an HTTP call
  informed by `http-req`
Where
&lt;query&gt; := a SPARQL SELECT query
&lt;endpoint&gt; the URL string of a SPARQL endpoint
&lt;bindings&gt; := [&lt;binding&gt; , ...]
&lt;binding&gt; := {&lt;var&gt; &lt;var-value&gt;, ...}
&lt;var&gt; is a variable specified in &lt;query&gt;
&lt;var-value&gt; := &lt;uri-value&gt; or &lt;literal-value&gt;
&lt;uri-value&gt; := {type uri, value &lt;uri&gt;}
&lt;literal-value&gt; :=  {type literal,
                     value &lt;value&gt;,
                     maybe datatype &lt;datatype&gt;,
                     maybe xml:lang &lt;lang&gt;
                    }
Note: see also `<a href="https://www.w3.org/TR/sparql11-results-json/">https://www.w3.org/TR/sparql11-results-json/</a>`
</pre></div></div><div class="public anchor" id="var-sparql-update"><h3>sparql-update</h3><div class="usage"><code>(sparql-update endpoint update)</code><code>(sparql-update endpoint update http-req)</code></div><div class="doc"><pre class="plaintext">Side Effect: Modifies the contents of `endpoint` per the update query 
`update`, possibly informed by http parameters  `http-req'
Returns the string returned by `endpoint` if successful.
Where
&lt;endpoint&gt; is a SPARQL update endpoint
&lt;update&gt; is a SPARQL update expression
&lt;http-req&gt; := {?param...}
&lt;param&gt; is anything described in `<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`
  Though :form-params will be overridden.
  This may be used for authentication parameters for example.
  Default parameters are {:cookie-policy :standard, :accept text/plain}
</pre></div></div><div class="public anchor" id="var-the-iri-factory"><h3>the-iri-factory</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-type-mapper"><h3>type-mapper</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Maps datatype names to xsd datatypes
</pre></div></div></div></body></html>