<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.sparql-endpoint.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="ont-app.sparql-endpoint.core.html"><div class="inner"><span>ont-app.sparql-endpoint.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-angle-bracket-uri"><div class="inner"><span>angle-bracket-uri</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-default-translators"><div class="inner"><span>default-translators</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-literal-.3ELangStr"><div class="inner"><span>literal-&gt;LangStr</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-make-simplifier"><div class="inner"><span>make-simplifier</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-meta-tagged-literal"><div class="inner"><span>meta-tagged-literal</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-parse-prologue"><div class="inner"><span>parse-prologue</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-parse-xsd-value"><div class="inner"><span>parse-xsd-value</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-simplifier-for-prologue"><div class="inner"><span>simplifier-for-prologue</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-simplifier-with-kwis"><div class="inner"><span>simplifier-with-kwis</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-simplify"><div class="inner"><span>simplify</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-ask"><div class="inner"><span>sparql-ask</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-construct"><div class="inner"><span>sparql-construct</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-query"><div class="inner"><span>sparql-query</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-select"><div class="inner"><span>sparql-select</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-sparql-update"><div class="inner"><span>sparql-update</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-type-mapper"><div class="inner"><span>type-mapper</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-update-translators"><div class="inner"><span>update-translators</span></div></a></li><li class="depth-1"><a href="ont-app.sparql-endpoint.core.html#var-xsd-type-uri"><div class="inner"><span>xsd-type-uri</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.sparql-endpoint.core</h1><div class="doc"><pre class="plaintext">Functions to support interacting with a SPARQL endpoint.
See also `<a href="https://www.w3.org/TR/sparql11-query">https://www.w3.org/TR/sparql11-query</a>`.
</pre></div><div class="public anchor" id="var-angle-bracket-uri"><h3>angle-bracket-uri</h3><div class="usage"><code>(angle-bracket-uri s)</code></div><div class="doc"><pre class="plaintext">returns &lt;`s`&gt; if it matches the scheme for a URI, else returns `s`.
</pre></div></div><div class="public anchor" id="var-default-translators"><h3>default-translators</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A map with keys :uri :lang :datatype, each mapping to `translator`
Where
- `translator` := (fn[var-value]) -&gt; `translated value`
- `var-value` :={'value' `value`
               'type' 'uri' | 'literal'
               ...maybe...
               'xml:lang' `lang` (if literal)
               'datatype' `datatype` (if literal)
              }
</pre></div></div><div class="public anchor" id="var-literal-.3ELangStr"><h3>literal-&gt;LangStr</h3><div class="usage"><code>(literal-&gt;LangStr literal)</code></div><div class="doc"><pre class="plaintext">Returns an instance of `LangStr` for `literal`
Where
- `literal`  is a language-tagged literal returned from a query</pre></div></div><div class="public anchor" id="var-make-simplifier"><h3>make-simplifier</h3><div class="usage"><code>(make-simplifier translators)</code></div><div class="doc"><pre class="plaintext">Returns `simplifier-fn` -&gt; for `translators`
Where
- `simplier-fn` := fn[`var-map`] -&gt; {`var-keyword` `translated-value`, ...}
- `translators` := m s.t. (keys m) = `keys`
- `k` is in `keys`
- `vfn` := fn [`value`] -&gt; `translated-value`
- `keys` := #{:uri :lang :datatype :bnode}
- `var-keyword` is keyword corresponding to `var`
- `translated-value` is `value` from `var-value`, translated using `translators`  </pre></div></div><div class="public anchor" id="var-meta-tagged-literal"><h3>meta-tagged-literal</h3><div class="usage"><code>(meta-tagged-literal literal)</code></div><div class="doc"><pre class="plaintext">Returns a reified object s.t. ^{:type `type`, `k` `v`, ...} Object.toString(this) -&gt; value
Where
- `literal` is a sparql binding value-map s.t.
  {type literal, `k` `v`, value `value` ...}
- `type` is one of ::langString ::datatype
- `k` is any key in `literal` except 'type' and 'value', e.g. xml:lang or datatype
- `v` is the value associated with `k` in `literal`
NOTE: type ::langString keys to a print-method  and the function
  `ont-app.vocabulary.lstr/read-LangStr`,  supporting the #langString reader macro
</pre></div></div><div class="public anchor" id="var-parse-prologue"><h3>parse-prologue</h3><div class="usage"><code>(parse-prologue query)</code></div><div class="doc"><pre class="plaintext">Returns [`base`, `uri-to-qname`, `qname-to-uri`] parsed from the 
  `prologue` to `query`
Where
- `base` is a URI string for the base of `query`
- `uri-to-qname` := fn[`uri`] -&gt; `quickname`, or `uri` if there was no matching
  prefix in `prolog`
- `qname-to-uri` := fn[`qname`] -&gt; `uri`   or `qname` if there
  was no matching prefix in `prologue`
- `uri` is typically a URI with a prefix defined in the `prologue`, but
  may be any string
- `qname` is typically a qname with a prefix defined in `prologue`,
  but may be any string
- `prologue` is the prologue parsed from `query`, for which see
  spex at `<a href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a>`.
</pre></div></div><div class="public anchor" id="var-parse-xsd-value"><h3>parse-xsd-value</h3><div class="usage"><code>(parse-xsd-value literal)</code></div><div class="doc"><pre class="plaintext">
Returns `translated-value` for `literal`
Where
- `literal` is a sparql binding value-map s.t.
  {type literal, datatype `datatype`, value `value` ...}
- `translated-value` is an instance of the xsd datatype associated with
  `datatype` specified for `value`, or `value` if no translation can be
  found.
- `datatype` is a string indicating the datatype associated with `value`,
  which may be an xsd datatype
</pre></div></div><div class="public anchor" id="var-simplifier-for-prologue"><h3>simplifier-for-prologue</h3><div class="usage"><code>(simplifier-for-prologue query)</code><code>(simplifier-for-prologue translators query)</code></div><div class="doc"><pre class="plaintext">Returns a function (fn[`var-map`] -&gt; {`var-keyword` `translated-value`, ...}
for each `var` in `var-map`, transating URIs into qnames derived from the
prologue to `query`, and otherwise using `translators` (default
`default-translators`)</pre></div></div><div class="public anchor" id="var-simplifier-with-kwis"><h3>simplifier-with-kwis</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A simplifier which translates URIs to keyword identifiers (KWIs).
See the ont-app.vocabulary.core module</pre></div></div><div class="public anchor" id="var-simplify"><h3>simplify</h3><div class="usage"><code>(simplify var-map)</code><code>(simplify translators var-map)</code></div><div class="doc"><pre class="plaintext">Returns {`var-keyword` `translated-value`, ...} for each `var` in `var-map`,
  translated according to `translators` (default `default-translators`)
Where
- `var-map` := {`var` `var-value`...}
- `var` is a string typically corresponding to a variable in a SELECT query
- `var-value` := m s.t. (keys m) :~ #{type value xml:lang datatype},
  per the SPARQL 1.1 specification for SELECT queries.
- `var-keyword` is keyword corresponding to `var`
- `translated-value` is `value` from `var-value`, translated using `translators`
- `translators` := m s.t. (keys m) :~ #{:uri :lang :datatype}, each of which
  maps to a (fn[var-value])-&gt; `translated-value`, depending on whether
  `var-value` represents a URI, a literal with a language tag, or a literal
  with a specified datatype. Default is simply to render the 'value' field.
- Note: see also `<a href="https://www.w3.org/TR/sparql11-results-json/">https://www.w3.org/TR/sparql11-results-json/</a>`
</pre></div></div><div class="public anchor" id="var-sparql-ask"><h3>sparql-ask</h3><div class="usage"><code>(sparql-ask endpoint query)</code><code>(sparql-ask endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns boolean value per `query` posed to `endpoint`, through an
HTTP call possibly informed by `http-req`.
Where
- `query` is a SPARQL ASK query
- `endpoint` is a SPARQL endpoint
- `http-req` := {`param` `spec`, ...}
- `param` is anything described in `<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`
  Though :form-params will be overridden.

</pre></div></div><div class="public anchor" id="var-sparql-construct"><h3>sparql-construct</h3><div class="usage"><code>(sparql-construct endpoint query)</code><code>(sparql-construct endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns `expression` for `query` posed to `endpoint`, possibly informed
  by `http-req`
Where
- `query` := a SPARQL CONSTRUCT query
- `endpoint` the URL string of a SPARQL endpoint
- `http-req` := {?param...}
- `param` is anything described in `<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`
  Though :form-params will be overridden.
  The default :accept parameter is text/turtle.
</pre></div></div><div class="public anchor" id="var-sparql-query"><h3>sparql-query</h3><div class="usage"><code>(sparql-query endpoint query)</code><code>(sparql-query endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns output of `response-body` for SPARQL `query`
  posed to `endpoint`, possibly informed by `http-req`
Where
- `response-body` is the body of the response to `query`, posed to `endpoint`
  via an HTTP GET call which may be informed by `param`s in `http-req`
- `http-req` := {`param` `spec`,...}, default is {}
- `param` is anything described in ``<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>``
  typically :debug or authentication parameters
  :query-params will be overridden.
  {:cookie-policy :standard} will be asserted by default
</pre></div></div><div class="public anchor" id="var-sparql-select"><h3>sparql-select</h3><div class="usage"><code>(sparql-select endpoint query)</code><code>(sparql-select endpoint query http-req)</code></div><div class="doc"><pre class="plaintext">
Returns `bindings` for `query` posed to `endpoint`, using an HTTP call
  informed by `http-req`
Where
- `query` := a SPARQL SELECT query
- `endpoint` the URL string of a SPARQL endpoint
- `bindings` := [`binding` , ...]
- `binding` := {`var` `var-value`, ...}
- `var` is a variable specified in `query`
- `var-value` := `uri-value` or `literal-value`
- `uri-value` := {type uri, value `uri`}
- `literal-value` :=  {type literal,
                     value `value`,
                     maybe datatype `datatype`,
                     maybe xml:lang `lang`
                    }
- Note: see also `<a href="https://www.w3.org/TR/sparql11-results-json/">https://www.w3.org/TR/sparql11-results-json/</a>`
</pre></div></div><div class="public anchor" id="var-sparql-update"><h3>sparql-update</h3><div class="usage"><code>(sparql-update endpoint update)</code><code>(sparql-update endpoint update http-req)</code></div><div class="doc"><pre class="plaintext">Side Effect: Modifies the contents of `endpoint` per the update query 
`update`, possibly informed by http parameters  `http-req'
Returns the string returned by `endpoint` if successful.
Where
- `endpoint` is a SPARQL update endpoint
- `update` is a SPARQL update expression
- `http-req` := {?param...}
- `param` is anything described in `<a href="https://github.com/dakrone/clj-http">https://github.com/dakrone/clj-http</a>`
   Though :form-params will be overridden.
   This may be used for authentication parameters for example.
   Default parameters are {:cookie-policy :standard, :accept text/plain}
</pre></div></div><div class="public anchor" id="var-type-mapper"><h3>type-mapper</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Maps datatype names to xsd datatypes
</pre></div></div><div class="public anchor" id="var-update-translators"><h3>update-translators</h3><div class="usage"><code>(update-translators translators k vfn)</code></div><div class="doc"><pre class="plaintext">Returns `translator`', for `k`, per `vfn`
Where
- `translators` := m s.t. (keys m) = `keys`
- `k` is in `keys`
- `vfn` := fn [`value`] -&gt; `translated-value`
- `keys` := #{:uri :lang :datatype :bnode} 
</pre></div></div><div class="public anchor" id="var-xsd-type-uri"><h3>xsd-type-uri</h3><div class="usage"><code>(xsd-type-uri x)</code></div><div class="doc"><pre class="plaintext">Returns xsd URI for (type `x`), or nil if there is no mapping in `type-mapper`.
Example: [1] -&gt; '<a href="http://www.w3.org/2001/XMLSchema#long&amp;apos">http://www.w3.org/2001/XMLSchema#long&amp;apos</a>;
Where:
- `x` is any value.</pre></div></div></div></body></html>