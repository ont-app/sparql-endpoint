#+TITLE: sparql-endpoint documentation
#+AUTHOR: Eric D. Scott
#+LANGUAGE: en
* Introduction
sparql-endpoint provides utilities for interfacing with [[https://www.w3.org/TR/sparql11-query/][SPARQL 1.1]]
endpoints in clojure.


* Installation
=sparql-endpoint= is available as a Maven artifact from clojars. 

With Leiningen:

#+BEGIN_SRC clojure
[ont-app/sparql-endpoint "0.1.0"]
#+END_SRC

* Functions
** Functions that interact with SPARQL endpoints

These involve POSTs to an [[https://www.w3.org/TR/sparql11-update/][update endpoint]] and GETs to a [[https://www.w3.org/TR/sparql11-query/][query
enpoint]]. There are special functions for ASK, SELECT and CONSTRUCT
queries. Each of these take mandatory _*endpoint*_ and _*query*_
arguments, and an optional _*http-req*_ argument.


*** Mandatory arguments: _endpoint_ and _query_
All of the basic query and update functions take two mandatory arguments: 

_*endpoint*_ is the URL of a SPARQL endpoint

_*query*_ is a string in an appropriate format for ASK, SELECT,
CONSTRUCT, or one of the UPDATE operations.

*** Optional argument: _http-req_

HTTP calls are done through [[https://github.com/dakrone/clj-http][clj-http]]. There is a third optional
_*http-req*_ argument which may include additional HTTP request
parameters.

For example if _endpoint_ requires authentication, you may specify
_{:basic-auth "myUserName:myPassword"}_

{:cookie-policy :standard} is asserted by default, but this can
be overridden. The _:query-params_ parameter is reserved, as it is
needed to specify the query to the endpoint.

*** sparql-ask 

This function takes an endpoint and a SPARQL ASK query and returns a boolean:

#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(sparql-ask 
    "https://query.wikidata.org/bigdata/namespace/wdq/sparql"
    "ASK WHERE {wd:Q5 rdfs:label \"human\"@en}")
;; --> true
#+END_SRC

*** sparql-select

This function takes as its _query_ parameter a SPARQL SELECT query:

#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(let [query "
# What is the English name for Q5?
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>
SELECT ?enLabel
WHERE
{
  wd:Q5 rdfs:label ?enLabel.
  Filter (Lang(?enLabel) = \"en\")
}"
  ]
  (sparql-select 
      "https://query.wikidata.org/bigdata/namespace/wdq/sparql"
      query)
;; => [{"enLabel" {"xml:lang" "en", "type" "literal", "value" "human"}}]
#+END_SRC

The bindings returned are direct translations of the JSON returned by
the endpoint. These can be mapped by more expressive _*simplifiers*_,
described below.

*** sparql-construct

This function takes a SPARQL CONSTRUCT query as its query parameter
and returns a string of [[https://www.w3.org/TR/turtle/][turtle]] describing the results.

#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(let [query "
# Things called 'human'
PREFIX eg: <http://example.com/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>

CONSTRUCT
{
  ?human a eg:Human.
}
WHERE
{
  ?human rdfs:label \"human\"@en.
}"
  ]
  (sparql-construct       
    "https://query.wikidata.org/bigdata/namespace/wdq/sparql"
     query))

;; -> "
@prefix eg: <http://example.com/> .
@prefix wd: <http://www.wikidata.org/entity/> .

wd:Q823310 a eg:Human .

wd:Q20094897 a eg:Human .

wd:Q26190966 a eg:Human .

wd:Q5 a eg:Human .
"
#+END_SRC

*** sparql-update 

This function POSTS its query parameter (CREATE, INSERT, DELETE, etc)
to the specified SPARQL update endpoint, and returns the plain text
response.

** Simplifiers

By default the output of _*sparql-select*_ is parsed JSON of raw
output of the endpoint, using [[https://www.w3.org/TR/sparql11-results-json/][the specification described by W3C]]. 


#+BEGIN_SRC clojure
{'value' <value>
 'type' 'uri' | 'literal'
 ;;...maybe...
 'xml:lang' <lang> (if literal)
 'datatype' <datatype> (if literal)
}
#+END_SRC

It is usually convenient to transform these bindings into simpler
representations. Hence the functions _*simplify*_ and
_*simplifier-for-prologue*_, described below.

*** simplify
The function _simplify_ will take a result binding and return a simplified map:

#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(let [query "
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>
SELECT ?enLabel
WHERE
{
  wd:Q5 rdfs:label ?enLabel.
  Filter (Lang(?enLabel) = \"en\")
}"
  ]
  (map simplify (sparql-select wikidata-endpoint query))

;; => ({:enLabel "human"})
;; Compare to [{"enLabel" {"xml:lang" "en", "type" "literal", "value" "human"}}]
#+END_SRC

**** Optional _*translators*_ argument
_simplify_ takes an optional argument _*translators*_, a map with three
keys: _*:uri*_, _*:lang*_ and _*:datatype*_. Default values for this map are
defined as the value *default-translators*.

 | key       | description                                                   | default                                      |
 |-----------+---------------------------------------------------------------+----------------------------------------------|
 | :uri      | value is a URI                                                | return raw value                             |
 | :lang     | value is literal and has a language tag, e.g. "en"            | return raw value                             |
 | :datatype | value is literal and has an assigned datatype, e.g. "xsd:int" | parse XSD values, otherwise return raw value |


By default the Jena library is referenced to translate [[https://www.w3.org/TR/xmlschema11-2/][xsd datatypes]]
into instances of an appropriate class. In the following example,
Obama's date of birth is translated to an instance of Jena's
*XSDDateTime*, which has a _*getYears*_ method...

#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(let [query "
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>
# What is Obama's date of birth?
SELECT ?dob
WHERE 
{
  wd:Q76 wdt:P569 ?dob.
} "
  ]
  (.getYears (:dob (nth (map simplify 
                             (sparql-select wikidata-endpoint query))
                         0))))
;; -> 1961

#+END_SRC

Any of these values can be overridden with custom functions by
merging *default-translators* with an overriding map.

*** simplifier-for-prologue

This function takes a query with a prologue (Including a set of PREFIX
declarations) and returns a simplifier function informed by a function
which maps full URIs to their corresponding quicknames. It is informed
by the function *parse-prologue*, described below.

Compare this...
#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(let [query "
# Things called 'Barack Obama'
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>
SELECT *
WHERE
{
  ?Q rdfs:label \"Barack Obama\"@en.
}"
  ]
  (map simplify
       (sparql-select wikidata-endpoint query)))
;; -> ({:Q "http://www.wikidata.org/entity/Q76"} 
;;     {:Q "http://www.wikidata.org/entity/Q47513588"}) 

#+END_SRC

... to this ...

#+BEGIN_SRC clojure
(use 'sparql-endpoint.core)
(let [query "
# Things called 'Barack Obama'
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX wd: <http://www.wikidata.org/entity/>
SELECT *
WHERE
{
  ?Q rdfs:label \"Barack Obama\"@en.
}"
  ]
  (map (simplifier-for-prologue query)
       (sparql-select wikidata-endpoint query)))

;; => ({:Q "wd:Q76"} {:Q "wd:Q47513588"}) 

#+END_SRC

** parse-prologue
This function takes a SPARQL query and returns a vector with three values:
_*base*_, _*uri-to-quickname*_, _*quickname-to-uri*_. 

| name             | description                                | 
|------------------+--------------------------------------------+
| base             | The base URI used to resolve relative URIs | 
| uri-to-quickname | fn[uri] -> corresponding quickname         | 
| quickname-to-uri | fn[quickname] -> corresponding full URI    | 

Given a string for which there is no prefix declaration in the query,
these last two functions will return their argument unchanged.
